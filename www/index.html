<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Royal Match Ultra</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;user-select:none}
  body{background:linear-gradient(135deg,#6a11cb 0%,#2575fc 100%);min-height:100vh;display:flex;flex-direction:column;align-items:center;color:#fff;overflow-x:hidden;padding:20px}
  .container{width:100%;max-width:1200px;display:flex;flex-direction:column;align-items:center}
  .header{width:100%;display:flex;justify-content:space-between;align-items:center;padding:15px 20px;background:rgba(0,0,0,.3);border-radius:20px;margin-bottom:20px;backdrop-filter:blur(10px)}
  .logo{display:flex;align-items:center;gap:10px;font-size:24px;font-weight:bold}
  .logo i{color:#ffcc00}
  .stats{display:flex;gap:20px}
  .stat{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,.2);padding:8px 15px;border-radius:50px}
  .stat i{color:#ffcc00}
  .main-content{display:grid;grid-template-columns:1fr 300px;gap:20px;width:100%}
  .game-board{background:rgba(0,0,0,.3);border-radius:20px;padding:20px;display:flex;flex-direction:column;backdrop-filter:blur(10px)}
  .board{display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);gap:6px;margin:0 auto;width:100%;max-width:500px;aspect-ratio:1/1}
  .tile{background:rgba(255,255,255,.1);border-radius:10px;display:flex;justify-content:center;align-items:center;font-size:28px;cursor:pointer;transition:transform .15s ease, box-shadow .15s ease;box-shadow:0 4px 8px rgba(0,0,0,.2);position:relative;overflow:hidden}
  .tile:hover{transform:scale(1.05);box-shadow:0 6px 12px rgba(0,0,0,.3)}
  .tile.selected{outline:3px solid #fff;transform:scale(.96)}
  .tile.hint{animation: hintPulse .8s ease-in-out 0s 6}
  @keyframes hintPulse {0%{transform:scale(1)}50%{transform:scale(1.08)}100%{transform:scale(1)}}
  .shape{width:70%;height:70%;border-radius:50%;background:#fff}
  .tile.red .shape{background:linear-gradient(135deg,#ff4e50 0%,#f9d423 100%)}
  .tile.blue .shape{background:linear-gradient(135deg,#4b6cb7 0%,#182848 100%)}
  .tile.green .shape{background:linear-gradient(135deg,#56ab2f 0%,#a8e063 100%)}
  .tile.purple .shape{background:linear-gradient(135deg,#8e2de2 0%,#4a00e0 100%)}
  .tile.yellow .shape{background:linear-gradient(135deg,#ffd200 0%,#f7971e 100%)}
  .tile.orange .shape{background:linear-gradient(135deg,#ff8008 0%,#ffc837 100%)}
  .objectives{display:flex;justify-content:center;gap:20px;margin:20px 0;flex-wrap:wrap}
  .objective{display:flex;align-items:center;gap:10px;background:rgba(255,255,255,.2);padding:10px 20px;border-radius:50px}
  .controls{display:flex;justify-content:center;gap:15px;margin-top:20px;flex-wrap:wrap}
  .btn{padding:12px 25px;border:none;border-radius:50px;background:linear-gradient(135deg,#ffcc00 0%,#ff9900 100%);color:#333;font-weight:bold;cursor:pointer;display:flex;align-items:center;gap:8px;transition:transform .15s ease, box-shadow .15s ease;box-shadow:0 4px 8px rgba(0,0,0,.2)}
  .btn:hover{transform:translateY(-3px);box-shadow:0 6px 12px rgba(0,0,0,.3)}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .sidebar{background:rgba(0,0,0,.3);border-radius:20px;padding:20px;display:flex;flex-direction:column;gap:20px;backdrop-filter:blur(10px)}
  .section{background:rgba(255,255,255,.1);padding:15px;border-radius:15px}
  .section h3{margin-bottom:15px;display:flex;align-items:center;gap:10px;font-size:18px}
  .section h3 i{color:#ffcc00}
  .boosters{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
  .booster{background:rgba(255,255,255,.15);border-radius:10px;padding:10px;display:flex;flex-direction:column;align-items:center;gap:5px;cursor:pointer;transition:.15s ease}
  .booster:hover{background:rgba(255,255,255,.25);transform:scale(1.05)}
  .booster i{font-size:24px;color:#ffcc00}
  .booster.active{outline:2px dashed #ffcc00}
  .levels{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;max-height:200px;overflow-y:auto;padding-right:5px}
  .levels::-webkit-scrollbar{width:5px}
  .levels::-webkit-scrollbar-thumb{background:rgba(255,255,255,.3);border-radius:10px}
  .level{background:rgba(255,255,255,.15);border-radius:10px;padding:10px;text-align:center;cursor:pointer;transition:.15s}
  .level:hover{background:rgba(255,255,255,.25)}
  .level.current{background:rgba(255,204,0,.3);box-shadow:0 0 10px rgba(255,204,0,.5)}
  .level.completed i{color:#ffcc00;margin-left:5px}
  .shop-items{display:flex;flex-direction:column;gap:10px}
  .shop-item{display:flex;align-items:center;gap:10px;padding:10px;background:rgba(255,255,255,.15);border-radius:10px}
  .progress-container{width:100%;background:rgba(255,255,255,.2);height:10px;border-radius:5px;margin:20px 0;overflow:hidden}
  .progress-bar{height:100%;background:linear-gradient(135deg,#ffcc00 0%,#ff9900 100%);border-radius:5px;width:0;transition:width .3s ease}
  .game-info{display:flex;justify-content:space-between;width:100%;margin-bottom:15px;flex-wrap:wrap;gap:10px}
  .moves,.score,.timer{background:rgba(0,0,0,.3);padding:10px 20px;border-radius:50px;display:flex;align-items:center;gap:8px}
  .moves i,.score i,.timer i{color:#ffcc00}
  @media (max-width:900px){.main-content{grid-template-columns:1fr}.board{max-width:420px}}
  @media (max-width:600px){.header{flex-direction:column;gap:15px}.stats{width:100%;justify-content:space-around}.board{max-width:320px}.tile{font-size:20px}.controls{flex-wrap:wrap}.btn{padding:10px 15px;font-size:14px}.game-info{justify-content:center}}
  @keyframes explode{0%{transform:scale(1);opacity:1}100%{transform:scale(2);opacity:0}}
  .explode{animation:explode .25s ease-out}
  .notification{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.85);color:#fff;padding:12px 20px;border-radius:50px;display:flex;align-items:center;gap:10px;z-index:1000;opacity:0;transition:opacity .25s ease;pointer-events:none}
  .notification.show{opacity:1}
  .achievement{position:fixed;right:20px;bottom:20px;background:rgba(0,0,0,.85);color:#fff;padding:15px;border-radius:15px;display:flex;align-items:center;gap:10px;z-index:1000;opacity:0;transition:opacity .25s ease;pointer-events:none}
  .achievement.show{opacity:1}
  .loading-screen{position:fixed;inset:0;background:linear-gradient(135deg,#6a11cb 0%,#2575fc 100%);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:2000;transition:opacity .4s ease}
  .loading-title{font-size:2rem;margin-bottom:16px;text-align:center}
  .loading-bar-container{width:280px;height:18px;background:rgba(255,255,255,.2);border-radius:10px;overflow:hidden;margin-bottom:12px}
  .loading-bar{height:100%;background:linear-gradient(135deg,#ffcc00 0%,#ff9900 100%);border-radius:10px;width:0;transition:width .4s ease}
  .loading-text{font-size:1rem}
</style>
</head>
<body>
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-title">Royal Match Ultra</div>
    <div class="loading-bar-container"><div class="loading-bar" id="loadingBar"></div></div>
    <div class="loading-text" id="loadingText">Chargement 0%</div>
  </div>

  <div class="container" id="gameContainer" style="display:none">
    <div class="header">
      <div class="logo"><i class="fas fa-crown"></i><span>Royal Match Ultra</span></div>
      <div class="stats">
        <div class="stat"><i class="fas fa-coins"></i><span id="coins">1250</span></div>
        <div class="stat"><i class="fas fa-heart"></i><span id="hearts">5</span></div>
        <div class="stat"><i class="fas fa-gem"></i><span id="gems">25</span></div>
      </div>
    </div>

    <div class="game-info">
      <div class="moves"><i class="fas fa-sync-alt"></i><span id="moves">15</span></div>
      <div class="score"><i class="fas fa-star"></i><span id="score">0</span></div>
      <div class="timer"><i class="fas fa-clock"></i><span id="time">120</span></div>
    </div>

    <div class="progress-container"><div class="progress-bar" id="level-progress"></div></div>

    <div class="main-content">
      <div class="game-board">
        <div class="objectives">
          <div class="objective"><i class="fas fa-bullseye"></i><span id="goalText">Objectif : 5000 points</span></div>
          <div class="objective"><i class="fas fa-bullseye"></i><span id="colorGoalText">20 bleus</span></div>
        </div>
        <div class="board" id="board"></div>
        <div class="controls">
          <button class="btn" id="restartBtn"><i class="fas fa-redo"></i>Recommencer</button>
          <button class="btn" id="hintBtn"><i class="fas fa-lightbulb"></i>Indice</button>
          <button class="btn" id="boostersBtn"><i class="fas fa-bolt"></i>Boosters</button>
        </div>
      </div>

      <div class="sidebar">
        <div class="section">
          <h3><i class="fas fa-fire"></i> Boosters</h3>
          <div class="boosters">
            <div class="booster" id="boosterBomb"><i class="fas fa-bomb"></i><span>Bombe</span><small id="bombCount">x3</small></div>
            <div class="booster" id="boosterRainbow"><i class="fas fa-rainbow"></i><span>Arc-en-ciel</span><small id="rainbowCount">x2</small></div>
            <div class="booster" id="boosterSwitch"><i class="fas fa-arrows-alt-h"></i><span>Ã‰change</span><small id="switchCount">x5</small></div>
            <div class="booster" id="boosterTime"><i class="fas fa-hourglass-half"></i><span>+ Temps</span><small id="timeCount">x2</small></div>
          </div>
        </div>
        <div class="section">
          <h3><i class="fas fa-list"></i> Niveaux</h3>
          <div class="levels" id="levels"></div>
        </div>
        <div class="section">
          <h3><i class="fas fa-store"></i> Boutique</h3>
          <div class="shop-items">
            <div class="shop-item"><i class="fas fa-coins"></i><div><div>1000 PiÃ¨ces</div><small>2,99 â‚¬</small></div></div>
            <div class="shop-item"><i class="fas fa-heart"></i><div><div>5 Vies</div><small>1,99 â‚¬</small></div></div>
            <div class="shop-item"><i class="fas fa-gem"></i><div><div>10 Gemmes</div><small>4,99 â‚¬</small></div></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="notification" id="notification"><i class="fas fa-check-circle"></i><span></span></div>
  <div class="achievement" id="achievement"><i class="fas fa-trophy"></i><div><div id="achTitle">Nouveau succÃ¨s !</div><small id="achDesc">Combo x3</small></div></div>

<script>
(() => {
  const COLUMNS = 8, ROWS = 8;
  const COLORS = ['red','blue','green','purple','yellow','orange'];
  const TARGET_SCORE = 5000;

  class Game {
    constructor() {
      this.level = 1; this.totalLevels = 15;
      this.score = 0; this.movesLeft = 15; this.timeLeft = 120;
      this.goalColor = 'blue'; this.goalColorLeft = 20;

      this.board = this.makeEmptyBoard();
      this.selected = null; this.busy = false;

      this.bombs = 3; this.rainbows = 2; this.switches = 5; this.times = 2;
      this.activeBooster = null; // 'bomb' | 'rainbow' | 'switch'

      this.timer = null;

      this.cacheDom();
      this.bindUI();
      this.loading();
    }

    cacheDom() {
      this.$board = document.getElementById('board');
      this.$moves = document.getElementById('moves');
      this.$score = document.getElementById('score');
      this.$time = document.getElementById('time');
      this.$progress = document.getElementById('level-progress');
      this.$goalText = document.getElementById('goalText');
      this.$colorGoalText = document.getElementById('colorGoalText');
      this.$levels = document.getElementById('levels');
      this.$notif = document.getElementById('notification');
      this.$notifText = this.$notif.querySelector('span');
      this.$ach = document.getElementById('achievement');
      this.$achTitle = document.getElementById('achTitle');
      this.$achDesc = document.getElementById('achDesc');

      this.$bBomb = document.getElementById('boosterBomb');
      this.$bRainbow = document.getElementById('boosterRainbow');
      this.$bSwitch = document.getElementById('boosterSwitch');
      this.$bTime = document.getElementById('boosterTime');
      this.$bombCount = document.getElementById('bombCount');
      this.$rainbowCount = document.getElementById('rainbowCount');
      this.$switchCount = document.getElementById('switchCount');
      this.$timeCount = document.getElementById('timeCount');
    }

    bindUI() {
      document.getElementById('restartBtn').addEventListener('click', () => this.resetLevel());
      document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
      document.getElementById('boostersBtn').addEventListener('click', () => this.toast('Choisis un booster Ã  droite.'));
      this.$bBomb.addEventListener('click', () => this.toggleBooster('bomb'));
      this.$bRainbow.addEventListener('click', () => this.toggleBooster('rainbow'));
      this.$bSwitch.addEventListener('click', () => this.toggleBooster('switch'));
      this.$bTime.addEventListener('click', () => this.useTime());
    }

    loading() {
      const scr = document.getElementById('loadingScreen');
      const bar = document.getElementById('loadingBar');
      const txt = document.getElementById('loadingText');
      let p = 0;
      const it = setInterval(() => {
        p = Math.min(100, p + 8 + Math.random()*10);
        bar.style.width = p + '%'; txt.textContent = 'Chargement ' + Math.round(p) + '%';
        if (p >= 100) {
          clearInterval(it);
          setTimeout(() => {
            scr.style.opacity = '0';
            setTimeout(() => {
              scr.style.display = 'none';
              document.getElementById('gameContainer').style.display = 'flex';
              this.start();
            }, 300);
          }, 200);
        }
      }, 120);
    }

    start() {
      this.generateBoardNoMatches();
      this.ensureHasMove();
      this.render();
      this.updateUI();
      this.generateLevelsList();
      this.startTimer();
    }

    resetLevel() {
      this.score = 0; this.movesLeft = 15; this.timeLeft = 120;
      this.goalColor = COLORS[Math.floor(Math.random()*COLORS.length)];
      this.goalColorLeft = 20 + Math.floor(this.level/2)*3;
      this.generateBoardNoMatches(); this.ensureHasMove();
      this.render(); this.updateUI(); this.restartTimer();
      this.toast('Niveau rÃ©initialisÃ©.');
    }

    nextLevel() {
      this.level = this.level % this.totalLevels + 1;
      this.resetLevel();
      [...this.$levels.querySelectorAll('.level')].forEach(l => l.classList.remove('current'));
      const cur = this.$levels.querySelector(`[data-level="${this.level}"]`);
      if (cur) cur.classList.add('current');
    }

    startTimer() {
      this.stopTimer();
      this.timer = setInterval(() => {
        this.timeLeft--; this.$time.textContent = this.timeLeft;
        if (this.timeLeft <= 0) this.endLevel(false);
      }, 1000);
    }
    restartTimer(){ this.startTimer(); }
    stopTimer(){ if (this.timer) clearInterval(this.timer); }

    updateUI() {
      this.$moves.textContent = this.movesLeft;
      this.$score.textContent = this.score;
      this.$time.textContent = this.timeLeft;
      const pct = Math.min(100, (this.score / TARGET_SCORE) * 100);
      this.$progress.style.width = pct + '%';
      this.$goalText.textContent = `Objectif : ${TARGET_SCORE.toLocaleString()} points`;
      this.$colorGoalText.textContent = `${this.goalColorLeft} ${this.goalColor}s`;
      this.$bombCount.textContent = 'x' + this.bombs;
      this.$rainbowCount.textContent = 'x' + this.rainbows;
      this.$switchCount.textContent = 'x' + this.switches;
      this.$timeCount.textContent = 'x' + this.times;
    }

    generateLevelsList() {
      this.$levels.innerHTML = '';
      for (let i=1;i<=this.totalLevels;i++){
        const d = document.createElement('div');
        d.className = 'level' + (i===this.level?' current':'');
        d.dataset.level = i; d.textContent = i;
        d.addEventListener('click', () => {
          if (i <= this.level) { this.level = i; this.resetLevel(); }
        });
        this.$levels.appendChild(d);
      }
    }

    makeEmptyBoard() {
      return Array.from({length:ROWS},()=>Array.from({length:COLUMNS},()=>null));
    }

    randomColor() { return COLORS[Math.floor(Math.random()*COLORS.length)]; }

    // Avoid starting matches
    generateBoardNoMatches() {
      this.board = this.makeEmptyBoard();
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLUMNS;c++){
          let color;
          do {
            color = this.randomColor();
          } while (
            (c>=2 && this.board[r][c-1]?.color===color && this.board[r][c-2]?.color===color) ||
            (r>=2 && this.board[r-1][c]?.color===color && this.board[r-2][c]?.color===color)
          );
          this.board[r][c] = { color };
        }
      }
    }

    // Rendering: rebuild grid in row-major order
    render() {
      this.$board.innerHTML = '';
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLUMNS;c++){
          const t = this.board[r][c];
          const el = document.createElement('div');
          el.className = `tile ${t.color}`;
          el.dataset.row = r; el.dataset.col = c;
          const shape = document.createElement('div'); shape.className = 'shape';
          el.appendChild(shape);
          el.addEventListener('click', () => this.onTileClick(r,c));
          this.$board.appendChild(el);
          t.el = el;
        }
      }
    }

    onTileClick(r,c) {
      if (this.busy) return;

      // Booster modes
      if (this.activeBooster === 'bomb') {
        if (this.bombs<=0) { this.toast('Plus de bombes.'); return; }
        this.bombs--; this.blast3x3(r,c);
        this.activeBooster = null; this.refreshBoosterUI(); return;
      }
      if (this.activeBooster === 'rainbow') {
        if (this.rainbows<=0) { this.toast('Plus dâ€™arc-en-ciel.'); return; }
        this.rainbows--; const color = this.board[r][c]?.color;
        this.clearColor(color); this.activeBooster = null; this.refreshBoosterUI(); return;
      }

      // Selection / swap
      const tile = this.board[r][c];
      if (!this.selected) {
        this.selected = {r,c};
        tile.el.classList.add('selected');
      } else {
        const {r: r0, c: c0} = this.selected;
        if (r0===r && c0===c) { tile.el.classList.remove('selected'); this.selected=null; return; }
        if (!this.areAdjacent(r0,c0,r,c)) {
          this.board[r0][c0].el.classList.remove('selected');
          this.selected = {r,c}; tile.el.classList.add('selected'); return;
        }
        // Try swap
        const freeSwap = (this.activeBooster === 'switch' && this.switches>0);
        this.trySwap(r0,c0,r,c, freeSwap);
        if (freeSwap) { this.switches--; this.activeBooster = null; this.refreshBoosterUI(); }
      }
    }

    areAdjacent(r1,c1,r2,c2){ return (Math.abs(r1-r2)+Math.abs(c1-c2))===1; }

    trySwap(r1,c1,r2,c2, freeSwap=false) {
      this.busy = true;
      // swap in model
      [this.board[r1][c1], this.board[r2][c2]] = [this.board[r2][c2], this.board[r1][c1]];
      this.render(); // reflect instantly

      const matches = this.findAllMatches();
      if (matches.length === 0) {
        // revert if no match
        [this.board[r1][c1], this.board[r2][c2]] = [this.board[r2][c2], this.board[r1][c1]];
        this.render();
        this.toast('Aucune correspondance.'); 
        this.clearSelection();
        this.busy = false;
        return;
      }
      // consume move if not free
      if (!freeSwap) {
        this.movesLeft--; this.updateUI();
        if (this.movesLeft < 0) this.movesLeft = 0;
      }
      this.resolveMatches(matches, 1);
    }

    clearSelection() {
      if (this.selected) {
        const {r,c} = this.selected;
        this.board[r][c]?.el?.classList?.remove('selected');
        this.selected = null;
      }
    }

    // Return array of sets: each set is cells to clear for a single match group
    findAllMatches() {
      const groups = [];
      const seen = Array.from({length:ROWS},()=>Array(COLUMNS).fill(false));
      // horizontal
      for (let r=0;r<ROWS;r++){
        let run=1;
        for (let c=1;c<=COLUMNS;c++){
          const same = c<COLUMNS && this.board[r][c]?.color===this.board[r][c-1]?.color;
          if (same) run++; 
          if (!same || c===COLUMNS){
            if (run>=3){
              const s = new Set();
              for (let k=c-run; k<c; k++) s.add(`${r},${k}`);
              groups.push(s);
            }
            run=1;
          }
        }
      }
      // vertical
      for (let c=0;c<COLUMNS;c++){
        let run=1;
        for (let r=1;r<=ROWS;r++){
          const same = r<ROWS && this.board[r][c]?.color===this.board[r-1][c]?.color;
          if (same) run++;
          if (!same || r===ROWS){
            if (run>=3){
              const s = new Set();
              for (let k=r-run; k<r; k++) s.add(`${k},${c}`);
              groups.push(s);
            }
            run=1;
          }
        }
      }
      // Merge overlapping groups
      if (groups.length===0) return [];
      const merged = [];
      const used = new Array(groups.length).fill(false);
      for (let i=0;i<groups.length;i++){
        if (used[i]) continue;
        let cur = new Set(groups[i]);
        used[i]=true;
        let changed=true;
        while(changed){
          changed=false;
          for (let j=0;j<groups.length;j++){
            if (used[j]) continue;
            if ([...groups[j]].some(k=>cur.has(k))){
              groups[j].forEach(k=>cur.add(k)); used[j]=true; changed=true;
            }
          }
        }
        merged.push(cur);
      }
      return merged;
    }

    resolveMatches(groups, chain) {
      // score with chain multiplier
      let cleared = 0;
      groups.forEach(s=>cleared+=s.size);
      const gained = cleared * 100 * chain;
      this.score += gained;
      this.$achTitle.textContent = 'Combo x' + chain;
      this.$achDesc.textContent = `+${gained} points`;
      this.flashAch();

      // color goals
      groups.forEach(s=>{
        s.forEach(key=>{
          const [r,c] = key.split(',').map(Number);
          if (this.board[r][c]?.color===this.goalColor) this.goalColorLeft = Math.max(0, this.goalColorLeft-1);
        });
      });

      // remove
      groups.forEach(s=>{
        s.forEach(key=>{
          const [r,c] = key.split(',').map(Number);
          this.board[r][c] = null;
        });
      });

      // collapse columns and refill
      for (let c=0;c<COLUMNS;c++){
        const colCells = [];
        for (let r=0;r<ROWS;r++){
          if (this.board[r][c]) colCells.push(this.board[r][c]);
        }
        const gaps = ROWS - colCells.length;
        const newTop = Array.from({length:gaps},()=>({color:this.randomColor()}));
        for (let r=0;r<ROWS;r++){
          this.board[r][c] = (r<gaps)? newTop[r] : colCells[r-gaps];
        }
      }
      this.render();
      this.updateUI();

      // chain reactions
      const next = this.findAllMatches();
      if (next.length>0){
        setTimeout(()=>this.resolveMatches(next, chain+1), 180);
        return;
      }

      // Check level end
      if (this.score>=TARGET_SCORE && this.goalColorLeft===0){
        this.endLevel(true); return;
      }

      // If no moves left, end
      if (this.movesLeft<=0){ this.endLevel(false); return; }

      // Ensure at least one move exists; if not, reshuffle
      if (!this.hasAnyMove()) {
        this.toast('Aucun coup possible. MÃ©langeâ€¦');
        this.reshuffle();
      }

      this.busy = false;
      this.clearSelection();
    }

    endLevel(win) {
      this.stopTimer();
      this.busy = false;
      if (win){
        this.toast('Niveau complÃ©tÃ© !');
        this.$achTitle.textContent='3 Ã©toiles âœ¨';
        this.$achDesc.textContent='Bravo !';
        this.flashAch();
        // mark completed
        const cur = this.$levels.querySelector(`[data-level="${this.level}"]`);
        if (cur && !cur.classList.contains('completed')){
          cur.classList.add('completed');
          cur.innerHTML = `${this.level} <i class="fas fa-check"></i>`;
        }
        setTimeout(()=>this.nextLevel(), 1500);
      } else {
        this.toast('Ã‰chec du niveau. RÃ©essaie.');
        setTimeout(()=>this.resetLevel(), 1200);
      }
    }

    toast(msg) {
      this.$notifText.textContent = msg;
      this.$notif.classList.add('show');
      setTimeout(()=>this.$notif.classList.remove('show'), 1600);
    }
    flashAch(){ this.$ach.classList.add('show'); setTimeout(()=>this.$ach.classList.remove('show'), 1200); }

    // Hint: find a valid swap and blink it
    showHint() {
      const mv = this.findFirstMove();
      if (!mv){ this.toast('Pas de coup. MÃ©langeâ€¦'); this.reshuffle(); return; }
      const {r1,c1,r2,c2} = mv;
      this.board[r1][c1].el.classList.add('hint');
      this.board[r2][c2].el.classList.add('hint');
      setTimeout(()=>{
        this.board[r1][c1].el.classList.remove('hint');
        this.board[r2][c2].el.classList.remove('hint');
      }, 1500);
    }

    // Scan for any swap that creates a match
    hasAnyMove(){ return !!this.findFirstMove(); }
    findFirstMove() {
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLUMNS;c++){
          const dirs = [[1,0],[0,1],[-1,0],[0,-1]];
          for (const [dr,dc] of dirs){
            const r2=r+dr, c2=c+dc;
            if (r2<0||r2>=ROWS||c2<0||c2>=COLUMNS) continue;
            // swap temporarily
            [this.board[r][c], this.board[r2][c2]] = [this.board[r2][c2], this.board[r][c]];
            const ok = this.findAllMatches().length>0;
            // revert
            [this.board[r][c], this.board[r2][c2]] = [this.board[r2][c2], this.board[r][c]];
            if (ok) return {r1:r,c1:c,r2,c2};
          }
        }
      }
      return null;
    }

    ensureHasMove(){
      if (!this.hasAnyMove()) this.reshuffle();
    }
    reshuffle() {
      // gather colors
      const pool = [];
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLUMNS;c++) pool.push(this.board[r][c].color);
      // Fisher-Yates shuffle
      for (let i=pool.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [pool[i],pool[j]]=[pool[j],pool[i]]; }
      let idx=0;
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLUMNS;c++) this.board[r][c]={color:pool[idx++]};
      // avoid instant matches at top rows massively; if matches happen, they seront rÃ©solues automatiquement au 1er move
      if (!this.hasAnyMove()) this.reshuffle(); // guarantee playability
      this.render();
    }

    // Boosters
    toggleBooster(kind){
      if (this.busy) return;
      // guard counts
      if (kind==='bomb' && this.bombs<=0) return this.toast('Plus de bombes.');
      if (kind==='rainbow' && this.rainbows<=0) return this.toast('Plus dâ€™arc-en-ciel.');
      if (kind==='switch' && this.switches<=0) return this.toast('Plus dâ€™Ã©changes gratuits.');
      this.activeBooster = (this.activeBooster===kind? null : kind);
      this.refreshBoosterUI();
      if (this.activeBooster==='bomb') this.toast('Clique une case pour exploser 3Ã—3.');
      if (this.activeBooster==='rainbow') this.toast('Clique une couleur Ã  nettoyer.');
      if (this.activeBooster==='switch') this.toast('Ton prochain Ã©change ne consommera pas de coup.');
    }
    refreshBoosterUI() {
      [this.$bBomb,this.$bRainbow,this.$bSwitch].forEach(b=>b.classList.remove('active'));
      if (this.activeBooster==='bomb') this.$bBomb.classList.add('active');
      if (this.activeBooster==='rainbow') this.$bRainbow.classList.add('active');
      if (this.activeBooster==='switch') this.$bSwitch.classList.add('active');
      this.updateUI();
    }
    blast3x3(r,c){
      this.busy = true;
      const cells = [];
      for (let dr=-1; dr<=1; dr++){
        for (let dc=-1; dc<=1; dc++){
          const rr=r+dr, cc=c+dc;
          if (rr>=0&&rr<ROWS&&cc>=0&&cc<COLUMNS) cells.push([rr,cc]);
        }
      }
      cells.forEach(([rr,cc])=>{
        this.board[rr][cc] = null;
      });
      this.resolveMatches([], 1); // pass through collapse/chain; scoring via collapse count not matches: add manual score
      this.score += cells.length * 60;
      this.updateUI();
    }
    clearColor(color){
      this.busy = true;
      let cleared=0;
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLUMNS;c++){
        if (this.board[r][c]?.color===color){ this.board[r][c]=null; cleared++; this.goalColorLeft = Math.max(0,this.goalColorLeft-1); }
      }
      this.score += cleared * 50; this.updateUI();
      this.resolveMatches([], 1);
    }
    useTime(){
      if (this.times<=0) return this.toast('Plus de bonus temps.');
      this.times--; this.timeLeft += 30; this.updateUI(); this.toast('+30 secondes !');
    }
  }

  // --- boot
  const game = new Game();
})();
</script>
</body>
</html>
